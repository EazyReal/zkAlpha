{
  "language": "Solidity",
  "sources": {
    "contracts/interfaces/I1nchRouter.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport {SafeERC20} from \"../libraries/SafeERC20.sol\";\nimport {UniERC20, IERC20} from \"../libraries/UniERC20.sol\";\n\nstruct SwapDescription {\n    IERC20 srcToken;\n    IERC20 dstToken;\n    address payable srcReceiver;\n    address payable dstReceiver;\n    uint256 amount;\n    uint256 minReturnAmount;\n    uint256 flags;\n}\n\ninterface IAggregationExecutor { \n    /// @notice propagates information about original msg.sender and executes arbitrary data \n    function execute(address msgSender) external payable;  // 0x4b64e492 \n}\n\ninterface IGenericRouter {\n\n    function swap(\n        IAggregationExecutor executor,\n        SwapDescription calldata desc,\n        bytes calldata permit,\n        bytes calldata data\n    ) external payable returns (uint256 returnAmount, uint256 spentAmount);\n}"
    },
    "contracts/interfaces/ICreate3Deployer.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\ninterface ICreate3Deployer {\n    function deploy(bytes32 salt, bytes calldata code) external returns (address);\n    function addressOf(bytes32 salt) external view returns (address);\n}\n"
    },
    "contracts/interfaces/IDaiLikePermit.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\ninterface IDaiLikePermit {\n    function permit(\n        address holder,\n        address spender,\n        uint256 nonce,\n        uint256 expiry,\n        bool allowed,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) external;\n}\n"
    },
    "contracts/interfaces/IERC20MetadataUppercase.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\ninterface IERC20MetadataUppercase {\n    function NAME() external view returns (string memory); // solhint-disable-line func-name-mixedcase\n\n    function SYMBOL() external view returns (string memory); // solhint-disable-line func-name-mixedcase\n}\n"
    },
    "contracts/interfaces/IPermit2.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\ninterface IPermit2 {\n    struct PermitDetails {\n        // ERC20 token address\n        address token;\n        // the maximum amount allowed to spend\n        uint160 amount;\n        // timestamp at which a spender's token allowances become invalid\n        uint48 expiration;\n        // an incrementing value indexed per owner,token,and spender for each signature\n        uint48 nonce;\n    }\n    /// @notice The permit message signed for a single token allownce\n    struct PermitSingle {\n        // the permit data for a single token alownce\n        PermitDetails details;\n        // address permissioned on the allowed tokens\n        address spender;\n        // deadline on the permit signature\n        uint256 sigDeadline;\n    }\n    /// @notice Packed allowance\n    struct PackedAllowance {\n        // amount allowed\n        uint160 amount;\n        // permission expiry\n        uint48 expiration;\n        // an incrementing value indexed per owner,token,and spender for each signature\n        uint48 nonce;\n    }\n\n    function transferFrom(address user, address spender, uint160 amount, address token) external;\n\n    function permit(address owner, PermitSingle memory permitSingle, bytes calldata signature) external;\n\n    function allowance(address user, address token, address spender) external view returns (PackedAllowance memory);\n}\n"
    },
    "contracts/interfaces/IWETH.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\n\ninterface IWETH is IERC20 {\n    event Deposit(address indexed dst, uint wad);\n\n    event Withdrawal(address indexed src, uint wad);\n\n    function deposit() external payable;\n\n    function withdraw(uint256 amount) external;\n}\n"
    },
    "contracts/IVerifier.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.17;\n\ninterface IDepositVerifier {\n    function verify(\n        uint256[5] calldata _publicInputs,\n        bytes calldata _proof\n    ) external view returns (bool);\n}\n\ninterface IWithdrawVerifier {\n    function verify(\n        uint256[5] calldata _publicInputs,\n        bytes calldata _proof\n    ) external view returns (bool);\n}\n\ninterface ISwapVerifier {\n    function verify(\n        uint256[4] calldata _publicInputs,\n        bytes calldata _proof\n    ) external view returns (bool);\n}\n\ninterface IFinalizeVerifier {\n    function verify(\n        uint256[3] calldata _publicInputs,\n        bytes calldata _proof\n    ) external view returns (bool);\n}\n"
    },
    "contracts/libraries/AddressArray.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\n/// @title Library that implements address array on mapping, stores array length at 0 index.\nlibrary AddressArray {\n    error IndexOutOfBounds();\n    error PopFromEmptyArray();\n    error OutputArrayTooSmall();\n\n    /// @dev Data struct containing raw mapping.\n    struct Data {\n        mapping(uint256 => uint256) _raw;\n    }\n\n    /// @dev Length of array.\n    function length(Data storage self) internal view returns (uint256) {\n        return self._raw[0] >> 160;\n    }\n\n    /// @dev Returns data item from `self` storage at `i`.\n    function at(Data storage self, uint256 i) internal view returns (address) {\n        return address(uint160(self._raw[i]));\n    }\n\n    /// @dev Returns list of addresses from storage `self`.\n    function get(Data storage self) internal view returns (address[] memory arr) {\n        uint256 lengthAndFirst = self._raw[0];\n        arr = new address[](lengthAndFirst >> 160);\n        _get(self, arr, lengthAndFirst);\n    }\n\n    /// @dev Puts list of addresses from `self` storage into `output` array.\n    function get(Data storage self, address[] memory output) internal view returns (address[] memory) {\n        return _get(self, output, self._raw[0]);\n    }\n\n    function _get(\n        Data storage self,\n        address[] memory output,\n        uint256 lengthAndFirst\n    ) private view returns (address[] memory) {\n        uint256 len = lengthAndFirst >> 160;\n        if (len > output.length) revert OutputArrayTooSmall();\n        if (len > 0) {\n            output[0] = address(uint160(lengthAndFirst));\n            unchecked {\n                for (uint256 i = 1; i < len; i++) {\n                    output[i] = address(uint160(self._raw[i]));\n                }\n            }\n        }\n        return output;\n    }\n\n    /// @dev Array push back `account` operation on storage `self`.\n    function push(Data storage self, address account) internal returns (uint256) {\n        unchecked {\n            uint256 lengthAndFirst = self._raw[0];\n            uint256 len = lengthAndFirst >> 160;\n            if (len == 0) {\n                self._raw[0] = (1 << 160) + uint160(account);\n            } else {\n                self._raw[0] = lengthAndFirst + (1 << 160);\n                self._raw[len] = uint160(account);\n            }\n            return len + 1;\n        }\n    }\n\n    /// @dev Array pop back operation for storage `self`.\n    function pop(Data storage self) internal {\n        unchecked {\n            uint256 lengthAndFirst = self._raw[0];\n            uint256 len = lengthAndFirst >> 160;\n            if (len == 0) revert PopFromEmptyArray();\n            self._raw[len - 1] = 0;\n            if (len > 1) {\n                self._raw[0] = lengthAndFirst - (1 << 160);\n            }\n        }\n    }\n\n    /// @dev Set element for storage `self` at `index` to `account`.\n    function set(\n        Data storage self,\n        uint256 index,\n        address account\n    ) internal {\n        uint256 len = length(self);\n        if (index >= len) revert IndexOutOfBounds();\n\n        if (index == 0) {\n            self._raw[0] = (len << 160) | uint160(account);\n        } else {\n            self._raw[index] = uint160(account);\n        }\n    }\n}\n"
    },
    "contracts/libraries/AddressLib.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\ntype Address is uint256;\n\n/**\n* @dev Library for working with addresses encoded as uint256 values, which can include flags in the highest bits.\n*/\nlibrary AddressLib {\n    uint256 private constant _LOW_160_BIT_MASK = (1 << 160) - 1;\n\n    /**\n    * @notice Returns the address representation of a uint256.\n    * @param a The uint256 value to convert to an address.\n    * @return The address representation of the provided uint256 value.\n    */\n    function get(Address a) internal pure returns (address) {\n        return address(uint160(Address.unwrap(a) & _LOW_160_BIT_MASK));\n    }\n\n    /**\n    * @notice Checks if a given flag is set for the provided address.\n    * @param a The address to check for the flag.\n    * @param flag The flag to check for in the provided address.\n    * @return True if the provided flag is set in the address, false otherwise.\n    */\n    function getFlag(Address a, uint256 flag) internal pure returns (bool) {\n        return (Address.unwrap(a) & flag) != 0;\n    }\n\n    /**\n    * @notice Returns a uint32 value stored at a specific bit offset in the provided address.\n    * @param a The address containing the uint32 value.\n    * @param offset The bit offset at which the uint32 value is stored.\n    * @return The uint32 value stored in the address at the specified bit offset.\n    */\n    function getUint32(Address a, uint256 offset) internal pure returns (uint32) {\n        return uint32(Address.unwrap(a) >> offset);\n    }\n\n    /**\n    * @notice Returns a uint64 value stored at a specific bit offset in the provided address.\n    * @param a The address containing the uint64 value.\n    * @param offset The bit offset at which the uint64 value is stored.\n    * @return The uint64 value stored in the address at the specified bit offset.\n    */\n    function getUint64(Address a, uint256 offset) internal pure returns (uint64) {\n        return uint64(Address.unwrap(a) >> offset);\n    }\n}\n"
    },
    "contracts/libraries/AddressSet.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport \"./AddressArray.sol\";\n\n/** @title Library that is using AddressArray library for AddressArray.Data\n * and allows Set operations on address storage data:\n * 1. add\n * 2. remove\n * 3. contains\n */\nlibrary AddressSet {\n    using AddressArray for AddressArray.Data;\n\n    /** @dev Data struct from AddressArray.Data items\n     * and lookup mapping address => index in data array.\n     */\n    struct Data {\n        AddressArray.Data items;\n        mapping(address => uint256) lookup;\n    }\n\n    /// @dev Length of data storage.\n    function length(Data storage s) internal view returns (uint256) {\n        return s.items.length();\n    }\n\n    /// @dev Returns data item from `s` storage at `index`.\n    function at(Data storage s, uint256 index) internal view returns (address) {\n        return s.items.at(index);\n    }\n\n    /// @dev Returns true if storage `s` has `item`.\n    function contains(Data storage s, address item) internal view returns (bool) {\n        return s.lookup[item] != 0;\n    }\n\n    /// @dev Adds `item` into storage `s` and returns true if successful.\n    function add(Data storage s, address item) internal returns (bool) {\n        if (s.lookup[item] > 0) {\n            return false;\n        }\n        s.lookup[item] = s.items.push(item);\n        return true;\n    }\n\n    /// @dev Removes `item` from storage `s` and returns true if successful.\n    function remove(Data storage s, address item) internal returns (bool) {\n        uint256 index = s.lookup[item];\n        if (index == 0) {\n            return false;\n        }\n        if (index < s.items.length()) {\n            unchecked {\n                address lastItem = s.items.at(s.items.length() - 1);\n                s.items.set(index - 1, lastItem);\n                s.lookup[lastItem] = index;\n            }\n        }\n        s.items.pop();\n        delete s.lookup[item];\n        return true;\n    }\n}\n"
    },
    "contracts/libraries/ECDSA.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport \"@openzeppelin/contracts/interfaces/IERC1271.sol\";\n\nlibrary ECDSA {\n    // EIP-2 still allows signature malleability for ecrecover(). Remove this possibility and make the signature\n    // unique. Appendix F in the Ethereum Yellow paper (https://ethereum.github.io/yellowpaper/paper.pdf), defines\n    // the valid range for s in (301): 0 < s < secp256k1n ÷ 2 + 1, and for v in (302): v ∈ {27, 28}. Most\n    // signatures from current libraries generate a unique signature with an s-value in the lower half order.\n    //\n    // If your library generates malleable signatures, such as s-values in the upper range, calculate a new s-value\n    // with 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEBAAEDCE6AF48A03BBFD25E8CD0364141 - s1 and flip v from 27 to 28 or\n    // vice versa. If your library also generates signatures with 0/1 for v instead 27/28, add 27 to v to accept\n    // these malleable signatures as well.\n    uint256 private constant _S_BOUNDARY = 0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF5D576E7357A4501DDFE92F46681B20A0 + 1;\n    uint256 private constant _COMPACT_S_MASK = 0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff;\n    uint256 private constant _COMPACT_V_SHIFT = 255;\n\n    function recover(\n        bytes32 hash,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) internal view returns (address signer) {\n        assembly (\"memory-safe\") { // solhint-disable-line no-inline-assembly\n            if lt(s, _S_BOUNDARY) {\n                let ptr := mload(0x40)\n\n                mstore(ptr, hash)\n                mstore(add(ptr, 0x20), v)\n                mstore(add(ptr, 0x40), r)\n                mstore(add(ptr, 0x60), s)\n                mstore(0, 0)\n                pop(staticcall(gas(), 0x1, ptr, 0x80, 0, 0x20))\n                signer := mload(0)\n            }\n        }\n    }\n\n    function recover(\n        bytes32 hash,\n        bytes32 r,\n        bytes32 vs\n    ) internal view returns (address signer) {\n        assembly (\"memory-safe\") { // solhint-disable-line no-inline-assembly\n            let s := and(vs, _COMPACT_S_MASK)\n            if lt(s, _S_BOUNDARY) {\n                let ptr := mload(0x40)\n\n                mstore(ptr, hash)\n                mstore(add(ptr, 0x20), add(27, shr(_COMPACT_V_SHIFT, vs)))\n                mstore(add(ptr, 0x40), r)\n                mstore(add(ptr, 0x60), s)\n                mstore(0, 0)\n                pop(staticcall(gas(), 0x1, ptr, 0x80, 0, 0x20))\n                signer := mload(0)\n            }\n        }\n    }\n\n    /// @dev WARNING!!!\n    /// There is a known signature malleability issue with two representations of signatures!\n    /// Even though this function is able to verify both standard 65-byte and compact 64-byte EIP-2098 signatures\n    /// one should never use raw signatures for any kind of invalidation logic in their code.\n    /// As the standard and compact representations are interchangeable any invalidation logic that relies on\n    /// signature uniqueness will get rekt.\n    /// More info: https://github.com/OpenZeppelin/openzeppelin-contracts/security/advisories/GHSA-4h98-2769-gh6h\n    function recover(bytes32 hash, bytes calldata signature) internal view returns (address signer) {\n        assembly (\"memory-safe\") { // solhint-disable-line no-inline-assembly\n            let ptr := mload(0x40)\n\n            // memory[ptr:ptr+0x80] = (hash, v, r, s)\n            switch signature.length\n            case 65 {\n                // memory[ptr+0x20:ptr+0x80] = (v, r, s)\n                mstore(add(ptr, 0x20), byte(0, calldataload(add(signature.offset, 0x40))))\n                calldatacopy(add(ptr, 0x40), signature.offset, 0x40)\n            }\n            case 64 {\n                // memory[ptr+0x20:ptr+0x80] = (v, r, s)\n                let vs := calldataload(add(signature.offset, 0x20))\n                mstore(add(ptr, 0x20), add(27, shr(_COMPACT_V_SHIFT, vs)))\n                calldatacopy(add(ptr, 0x40), signature.offset, 0x20)\n                mstore(add(ptr, 0x60), and(vs, _COMPACT_S_MASK))\n            }\n            default {\n                ptr := 0\n            }\n\n            if ptr {\n                if lt(mload(add(ptr, 0x60)), _S_BOUNDARY) {\n                    // memory[ptr:ptr+0x20] = (hash)\n                    mstore(ptr, hash)\n\n                    mstore(0, 0)\n                    pop(staticcall(gas(), 0x1, ptr, 0x80, 0, 0x20))\n                    signer := mload(0)\n                }\n            }\n        }\n    }\n\n    function recoverOrIsValidSignature(\n        address signer,\n        bytes32 hash,\n        bytes calldata signature\n    ) internal view returns (bool success) {\n        if (signer == address(0)) return false;\n        if ((signature.length == 64 || signature.length == 65) && recover(hash, signature) == signer) {\n            return true;\n        }\n        return isValidSignature(signer, hash, signature);\n    }\n\n    function recoverOrIsValidSignature(\n        address signer,\n        bytes32 hash,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) internal view returns (bool success) {\n        if (signer == address(0)) return false;\n        if (recover(hash, v, r, s) == signer) {\n            return true;\n        }\n        return isValidSignature(signer, hash, v, r, s);\n    }\n\n    function recoverOrIsValidSignature(\n        address signer,\n        bytes32 hash,\n        bytes32 r,\n        bytes32 vs\n    ) internal view returns (bool success) {\n        if (signer == address(0)) return false;\n        if (recover(hash, r, vs) == signer) {\n            return true;\n        }\n        return isValidSignature(signer, hash, r, vs);\n    }\n\n    function recoverOrIsValidSignature65(\n        address signer,\n        bytes32 hash,\n        bytes32 r,\n        bytes32 vs\n    ) internal view returns (bool success) {\n        if (signer == address(0)) return false;\n        if (recover(hash, r, vs) == signer) {\n            return true;\n        }\n        return isValidSignature65(signer, hash, r, vs);\n    }\n\n    function isValidSignature(\n        address signer,\n        bytes32 hash,\n        bytes calldata signature\n    ) internal view returns (bool success) {\n        // (bool success, bytes memory data) = signer.staticcall(abi.encodeWithSelector(IERC1271.isValidSignature.selector, hash, signature));\n        // return success && data.length >= 4 && abi.decode(data, (bytes4)) == IERC1271.isValidSignature.selector;\n        bytes4 selector = IERC1271.isValidSignature.selector;\n        assembly (\"memory-safe\") { // solhint-disable-line no-inline-assembly\n            let ptr := mload(0x40)\n\n            mstore(ptr, selector)\n            mstore(add(ptr, 0x04), hash)\n            mstore(add(ptr, 0x24), 0x40)\n            mstore(add(ptr, 0x44), signature.length)\n            calldatacopy(add(ptr, 0x64), signature.offset, signature.length)\n            if staticcall(gas(), signer, ptr, add(0x64, signature.length), 0, 0x20) {\n                success := and(eq(selector, mload(0)), eq(returndatasize(), 0x20))\n            }\n        }\n    }\n\n    function isValidSignature(\n        address signer,\n        bytes32 hash,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) internal view returns (bool success) {\n        bytes4 selector = IERC1271.isValidSignature.selector;\n        assembly (\"memory-safe\") { // solhint-disable-line no-inline-assembly\n            let ptr := mload(0x40)\n\n            mstore(ptr, selector)\n            mstore(add(ptr, 0x04), hash)\n            mstore(add(ptr, 0x24), 0x40)\n            mstore(add(ptr, 0x44), 65)\n            mstore(add(ptr, 0x64), r)\n            mstore(add(ptr, 0x84), s)\n            mstore8(add(ptr, 0xa4), v)\n            if staticcall(gas(), signer, ptr, 0xa5, 0, 0x20) {\n                success := and(eq(selector, mload(0)), eq(returndatasize(), 0x20))\n            }\n        }\n    }\n\n    function isValidSignature(\n        address signer,\n        bytes32 hash,\n        bytes32 r,\n        bytes32 vs\n    ) internal view returns (bool success) {\n        // (bool success, bytes memory data) = signer.staticcall(abi.encodeWithSelector(IERC1271.isValidSignature.selector, hash, abi.encodePacked(r, vs)));\n        // return success && data.length >= 4 && abi.decode(data, (bytes4)) == IERC1271.isValidSignature.selector;\n        bytes4 selector = IERC1271.isValidSignature.selector;\n        assembly (\"memory-safe\") { // solhint-disable-line no-inline-assembly\n            let ptr := mload(0x40)\n\n            mstore(ptr, selector)\n            mstore(add(ptr, 0x04), hash)\n            mstore(add(ptr, 0x24), 0x40)\n            mstore(add(ptr, 0x44), 64)\n            mstore(add(ptr, 0x64), r)\n            mstore(add(ptr, 0x84), vs)\n            if staticcall(gas(), signer, ptr, 0xa4, 0, 0x20) {\n                success := and(eq(selector, mload(0)), eq(returndatasize(), 0x20))\n            }\n        }\n    }\n\n    function isValidSignature65(\n        address signer,\n        bytes32 hash,\n        bytes32 r,\n        bytes32 vs\n    ) internal view returns (bool success) {\n        // (bool success, bytes memory data) = signer.staticcall(abi.encodeWithSelector(IERC1271.isValidSignature.selector, hash, abi.encodePacked(r, vs & ~uint256(1 << 255), uint8(vs >> 255))));\n        // return success && data.length >= 4 && abi.decode(data, (bytes4)) == IERC1271.isValidSignature.selector;\n        bytes4 selector = IERC1271.isValidSignature.selector;\n        assembly (\"memory-safe\") { // solhint-disable-line no-inline-assembly\n            let ptr := mload(0x40)\n\n            mstore(ptr, selector)\n            mstore(add(ptr, 0x04), hash)\n            mstore(add(ptr, 0x24), 0x40)\n            mstore(add(ptr, 0x44), 65)\n            mstore(add(ptr, 0x64), r)\n            mstore(add(ptr, 0x84), and(vs, _COMPACT_S_MASK))\n            mstore8(add(ptr, 0xa4), add(27, shr(_COMPACT_V_SHIFT, vs)))\n            if staticcall(gas(), signer, ptr, 0xa5, 0, 0x20) {\n                success := and(eq(selector, mload(0)), eq(returndatasize(), 0x20))\n            }\n        }\n    }\n\n    function toEthSignedMessageHash(bytes32 hash) internal pure returns (bytes32 res) {\n        // 32 is the length in bytes of hash, enforced by the type signature above\n        // return keccak256(abi.encodePacked(\"\\x19Ethereum Signed Message:\\n32\", hash));\n        assembly (\"memory-safe\") { // solhint-disable-line no-inline-assembly\n            mstore(0, 0x19457468657265756d205369676e6564204d6573736167653a0a333200000000) // \"\\x19Ethereum Signed Message:\\n32\"\n            mstore(28, hash)\n            res := keccak256(0, 60)\n        }\n    }\n\n    function toTypedDataHash(bytes32 domainSeparator, bytes32 structHash) internal pure returns (bytes32 res) {\n        // return keccak256(abi.encodePacked(\"\\x19\\x01\", domainSeparator, structHash));\n        assembly (\"memory-safe\") { // solhint-disable-line no-inline-assembly\n            let ptr := mload(0x40)\n            mstore(ptr, 0x1901000000000000000000000000000000000000000000000000000000000000) // \"\\x19\\x01\"\n            mstore(add(ptr, 0x02), domainSeparator)\n            mstore(add(ptr, 0x22), structHash)\n            res := keccak256(ptr, 66)\n        }\n    }\n}\n"
    },
    "contracts/libraries/RevertReasonForwarder.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\n/// @title Revert reason forwarder.\nlibrary RevertReasonForwarder {\n    /// @dev Forwards latest externall call revert.\n    function reRevert() internal pure {\n        // bubble up revert reason from latest external call\n        assembly (\"memory-safe\") { // solhint-disable-line no-inline-assembly\n            let ptr := mload(0x40)\n            returndatacopy(ptr, 0, returndatasize())\n            revert(ptr, returndatasize())\n        }\n    }\n}\n"
    },
    "contracts/libraries/RevertReasonParser.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport \"./StringUtil.sol\";\n\n/** @title Library that allows to parse unsuccessful arbitrary calls revert reasons.\n * See https://solidity.readthedocs.io/en/latest/control-structures.html#revert for details.\n * Note that we assume revert reason being abi-encoded as Error(string) so it may fail to parse reason\n * if structured reverts appear in the future.\n *\n * All unsuccessful parsings get encoded as Unknown(data) string\n */\nlibrary RevertReasonParser {\n    using StringUtil for uint256;\n    using StringUtil for bytes;\n\n    error InvalidRevertReason();\n\n    bytes4 private constant _ERROR_SELECTOR = bytes4(keccak256(\"Error(string)\"));\n    bytes4 private constant _PANIC_SELECTOR = bytes4(keccak256(\"Panic(uint256)\"));\n\n    /// @dev Parses error `data` and returns actual with `prefix`.\n    function parse(bytes memory data, string memory prefix) internal pure returns (string memory) {\n        // https://solidity.readthedocs.io/en/latest/control-structures.html#revert\n        // We assume that revert reason is abi-encoded as Error(string)\n        bytes4 selector;\n        if (data.length >= 4) {\n            assembly (\"memory-safe\") { // solhint-disable-line no-inline-assembly\n                selector := mload(add(data, 0x20))\n            }\n        }\n\n        // 68 = 4-byte selector + 32 bytes offset + 32 bytes length\n        if (selector == _ERROR_SELECTOR && data.length >= 68) {\n            string memory reason;\n            assembly (\"memory-safe\") { // solhint-disable-line no-inline-assembly\n                // 68 = 32 bytes data length + 4-byte selector + 32 bytes offset\n                reason := add(data, 68)\n            }\n            /*\n                revert reason is padded up to 32 bytes with ABI encoder: Error(string)\n                also sometimes there is extra 32 bytes of zeros padded in the end:\n                https://github.com/ethereum/solidity/issues/10170\n                because of that we can't check for equality and instead check\n                that string length + extra 68 bytes is equal or greater than overall data length\n            */\n            if (data.length >= 68 + bytes(reason).length) {\n                return string.concat(prefix, \"Error(\", reason, \")\");\n            }\n        }\n        // 36 = 4-byte selector + 32 bytes integer\n        else if (selector == _PANIC_SELECTOR && data.length == 36) {\n            uint256 code;\n            assembly (\"memory-safe\") { // solhint-disable-line no-inline-assembly\n                // 36 = 32 bytes data length + 4-byte selector\n                code := mload(add(data, 36))\n            }\n            return string.concat(prefix, \"Panic(\", code.toHex(), \")\");\n        }\n        return string.concat(prefix, \"Unknown(\", data.toHex(), \")\");\n    }\n}\n"
    },
    "contracts/libraries/SafeERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/extensions/draft-IERC20Permit.sol\";\nimport \"../interfaces/IDaiLikePermit.sol\";\nimport \"../interfaces/IPermit2.sol\";\nimport \"../interfaces/IWETH.sol\";\nimport \"../libraries/RevertReasonForwarder.sol\";\n\n/**\n * @title Implements efficient safe methods for ERC20 interface.\n * @notice Compared to the standard ERC20, this implementation offers several enhancements:\n * 1. more gas-efficient, providing significant savings in transaction costs.\n * 2. support for different permit implementations\n * 3. forceApprove functionality\n * 4. support for WETH deposit and withdraw\n */\nlibrary SafeERC20 {\n    error SafeTransferFailed();\n    error SafeTransferFromFailed();\n    error ForceApproveFailed();\n    error SafeIncreaseAllowanceFailed();\n    error SafeDecreaseAllowanceFailed();\n    error SafePermitBadLength();\n    error Permit2TransferAmountTooHigh();\n\n    // Uniswap Permit2 address\n    address private constant _PERMIT2 = 0x000000000022D473030F116dDEE9F6B43aC78BA3;\n    bytes4 private constant _PERMIT_LENGTH_ERROR = 0x68275857;  // SafePermitBadLength.selector\n    uint256 private constant _RAW_CALL_GAS_LIMIT = 5000;\n\n    /**\n     * @notice Fetches the balance of a specific ERC20 token held by an account.\n     * Consumes less gas then regular `ERC20.balanceOf`.\n     * @param token The IERC20 token contract for which the balance will be fetched.\n     * @param account The address of the account whose token balance will be fetched.\n     * @return tokenBalance The balance of the specified ERC20 token held by the account.\n     */\n    function safeBalanceOf(\n        IERC20 token,\n        address account\n    ) internal view returns(uint256 tokenBalance) {\n        bytes4 selector = IERC20.balanceOf.selector;\n        assembly (\"memory-safe\") { // solhint-disable-line no-inline-assembly\n            mstore(0x00, selector)\n            mstore(0x04, account)\n            let success := staticcall(gas(), token, 0x00, 0x24, 0x00, 0x20)\n            tokenBalance := mload(0)\n\n            if or(iszero(success), lt(returndatasize(), 0x20)) {\n                let ptr := mload(0x40)\n                returndatacopy(ptr, 0, returndatasize())\n                revert(ptr, returndatasize())\n            }\n        }\n    }\n\n    /**\n     * @notice Attempts to safely transfer tokens from one address to another.\n     * @dev If permit2 is true, uses the Permit2 standard; otherwise uses the standard ERC20 transferFrom. \n     * Either requires `true` in return data, or requires target to be smart-contract and empty return data.\n     * @param token The IERC20 token contract from which the tokens will be transferred.\n     * @param from The address from which the tokens will be transferred.\n     * @param to The address to which the tokens will be transferred.\n     * @param amount The amount of tokens to transfer.\n     * @param permit2 If true, uses the Permit2 standard for the transfer; otherwise uses the standard ERC20 transferFrom.\n     */\n    function safeTransferFromUniversal(\n        IERC20 token,\n        address from,\n        address to,\n        uint256 amount,\n        bool permit2\n    ) internal {\n        if (permit2) {\n            safeTransferFromPermit2(token, from, to, amount);\n        } else {\n            safeTransferFrom(token, from, to, amount);\n        }\n    }\n\n    /**\n     * @notice Attempts to safely transfer tokens from one address to another using the ERC20 standard.\n     * @dev Either requires `true` in return data, or requires target to be smart-contract and empty return data.\n     * @param token The IERC20 token contract from which the tokens will be transferred.\n     * @param from The address from which the tokens will be transferred.\n     * @param to The address to which the tokens will be transferred.\n     * @param amount The amount of tokens to transfer.\n     */\n    function safeTransferFrom(\n        IERC20 token,\n        address from,\n        address to,\n        uint256 amount\n    ) internal {\n        bytes4 selector = token.transferFrom.selector;\n        bool success;\n        assembly (\"memory-safe\") { // solhint-disable-line no-inline-assembly\n            let data := mload(0x40)\n\n            mstore(data, selector)\n            mstore(add(data, 0x04), from)\n            mstore(add(data, 0x24), to)\n            mstore(add(data, 0x44), amount)\n            success := call(gas(), token, 0, data, 100, 0x0, 0x20)\n            if success {\n                switch returndatasize()\n                case 0 {\n                    success := gt(extcodesize(token), 0)\n                }\n                default {\n                    success := and(gt(returndatasize(), 31), eq(mload(0), 1))\n                }\n            }\n        }\n        if (!success) revert SafeTransferFromFailed();\n    }\n\n    /**\n     * @notice Attempts to safely transfer tokens from one address to another using the Permit2 standard.\n     * @dev Either requires `true` in return data, or requires target to be smart-contract and empty return data.\n     * @param token The IERC20 token contract from which the tokens will be transferred.\n     * @param from The address from which the tokens will be transferred.\n     * @param to The address to which the tokens will be transferred.\n     * @param amount The amount of tokens to transfer.\n     */\n    function safeTransferFromPermit2(\n        IERC20 token,\n        address from,\n        address to,\n        uint256 amount\n    ) internal {\n        if (amount > type(uint160).max) revert Permit2TransferAmountTooHigh();\n        bytes4 selector = IPermit2.transferFrom.selector;\n        bool success;\n        assembly (\"memory-safe\") { // solhint-disable-line no-inline-assembly\n            let data := mload(0x40)\n\n            mstore(data, selector)\n            mstore(add(data, 0x04), from)\n            mstore(add(data, 0x24), to)\n            mstore(add(data, 0x44), amount)\n            mstore(add(data, 0x64), token)\n            success := call(gas(), _PERMIT2, 0, data, 0x84, 0x0, 0x0)\n            if success {\n                success := gt(extcodesize(_PERMIT2), 0)\n            }\n        }\n        if (!success) revert SafeTransferFromFailed();\n    }\n\n    /**\n     * @notice Attempts to safely transfer tokens to another address.\n     * @dev Either requires `true` in return data, or requires target to be smart-contract and empty return data.\n     * @param token The IERC20 token contract from which the tokens will be transferred.\n     * @param to The address to which the tokens will be transferred.\n     * @param value The amount of tokens to transfer.\n     */\n    function safeTransfer(\n        IERC20 token,\n        address to,\n        uint256 value\n    ) internal {\n        if (!_makeCall(token, token.transfer.selector, to, value)) {\n            revert SafeTransferFailed();\n        }\n    }\n\n    /**\n     * @notice Attempts to approve a spender to spend a certain amount of tokens.\n     * @dev If `approve(from, to, amount)` fails, it tries to set the allowance to zero, and retries the `approve` call.\n     * @param token The IERC20 token contract on which the call will be made.\n     * @param spender The address which will spend the funds.\n     * @param value The amount of tokens to be spent.\n     */\n    function forceApprove(\n        IERC20 token,\n        address spender,\n        uint256 value\n    ) internal {\n        if (!_makeCall(token, token.approve.selector, spender, value)) {\n            if (\n                !_makeCall(token, token.approve.selector, spender, 0) ||\n                !_makeCall(token, token.approve.selector, spender, value)\n            ) {\n                revert ForceApproveFailed();\n            }\n        }\n    }\n\n    /**\n     * @notice Safely increases the allowance of a spender.\n     * @dev Increases with safe math check. Checks if the increased allowance will overflow, if yes, then it reverts the transaction.\n     * Then uses `forceApprove` to increase the allowance.\n     * @param token The IERC20 token contract on which the call will be made.\n     * @param spender The address which will spend the funds.\n     * @param value The amount of tokens to increase the allowance by.\n     */\n    function safeIncreaseAllowance(\n        IERC20 token,\n        address spender,\n        uint256 value\n    ) internal {\n        uint256 allowance = token.allowance(address(this), spender);\n        if (value > type(uint256).max - allowance) revert SafeIncreaseAllowanceFailed();\n        forceApprove(token, spender, allowance + value);\n    }\n\n    /**\n     * @notice Safely decreases the allowance of a spender.\n     * @dev Decreases with safe math check. Checks if the decreased allowance will underflow, if yes, then it reverts the transaction.\n     * Then uses `forceApprove` to increase the allowance.\n     * @param token The IERC20 token contract on which the call will be made.\n     * @param spender The address which will spend the funds.\n     * @param value The amount of tokens to decrease the allowance by.\n     */\n    function safeDecreaseAllowance(\n        IERC20 token,\n        address spender,\n        uint256 value\n    ) internal {\n        uint256 allowance = token.allowance(address(this), spender);\n        if (value > allowance) revert SafeDecreaseAllowanceFailed();\n        forceApprove(token, spender, allowance - value);\n    }\n\n    /**\n     * @notice Attempts to execute the `permit` function on the provided token with the sender and contract as parameters.\n     * Permit type is determined automatically based on permit calldata (IERC20Permit, IDaiLikePermit, and IPermit2).\n     * @dev Wraps `tryPermit` function and forwards revert reason if permit fails.\n     * @param token The IERC20 token to execute the permit function on.\n     * @param permit The permit data to be used in the function call.\n     */\n    function safePermit(IERC20 token, bytes calldata permit) internal {\n        if (!tryPermit(token, msg.sender, address(this), permit)) RevertReasonForwarder.reRevert();\n    }\n\n    /**\n     * @notice Attempts to execute the `permit` function on the provided token with custom owner and spender parameters. \n     * Permit type is determined automatically based on permit calldata (IERC20Permit, IDaiLikePermit, and IPermit2).\n     * @dev Wraps `tryPermit` function and forwards revert reason if permit fails.\n     * @param token The IERC20 token to execute the permit function on.\n     * @param owner The owner of the tokens for which the permit is made.\n     * @param spender The spender allowed to spend the tokens by the permit.\n     * @param permit The permit data to be used in the function call.\n     */\n    function safePermit(IERC20 token, address owner, address spender, bytes calldata permit) internal {\n        if (!tryPermit(token, owner, spender, permit)) RevertReasonForwarder.reRevert();\n    }\n\n    /**\n     * @notice Attempts to execute the `permit` function on the provided token with the sender and contract as parameters.\n     * @dev Invokes `tryPermit` with sender as owner and contract as spender.\n     * @param token The IERC20 token to execute the permit function on.\n     * @param permit The permit data to be used in the function call.\n     * @return success Returns true if the permit function was successfully executed, false otherwise.\n     */\n    function tryPermit(IERC20 token, bytes calldata permit) internal returns(bool success) {\n        return tryPermit(token, msg.sender, address(this), permit);\n    }\n\n    /**\n     * @notice The function attempts to call the permit function on a given ERC20 token.\n     * @dev The function is designed to support a variety of permit functions, namely: IERC20Permit, IDaiLikePermit, and IPermit2.\n     * It accommodates both Compact and Full formats of these permit types.\n     * Please note, it is expected that the `expiration` parameter for the compact Permit2 and the `deadline` parameter \n     * for the compact Permit are to be incremented by one before invoking this function. This approach is motivated by\n     * gas efficiency considerations; as the unlimited expiration period is likely to be the most common scenario, and \n     * zeros are cheaper to pass in terms of gas cost. Thus, callers should increment the expiration or deadline by one\n     * before invocation for optimized performance.\n     * @param token The address of the ERC20 token on which to call the permit function.\n     * @param owner The owner of the tokens. This address should have signed the off-chain permit.\n     * @param spender The address which will be approved for transfer of tokens.\n     * @param permit The off-chain permit data, containing different fields depending on the type of permit function.\n     * @return success A boolean indicating whether the permit call was successful.\n     */\n    function tryPermit(IERC20 token, address owner, address spender, bytes calldata permit) internal returns(bool success) {\n        // load function selectors for different permit standards\n        bytes4 permitSelector = IERC20Permit.permit.selector;\n        bytes4 daiPermitSelector = IDaiLikePermit.permit.selector;\n        bytes4 permit2Selector = IPermit2.permit.selector;\n        assembly (\"memory-safe\") { // solhint-disable-line no-inline-assembly\n            let ptr := mload(0x40)\n\n            // Switch case for different permit lengths, indicating different permit standards\n            switch permit.length\n            // Compact IERC20Permit\n            case 100 {\n                mstore(ptr, permitSelector)     // store selector\n                mstore(add(ptr, 0x04), owner)   // store owner\n                mstore(add(ptr, 0x24), spender) // store spender\n\n                // Compact IERC20Permit.permit(uint256 value, uint32 deadline, uint256 r, uint256 vs)\n                {  // stack too deep\n                    let deadline := shr(224, calldataload(add(permit.offset, 0x20))) // loads permit.offset 0x20..0x23\n                    let vs := calldataload(add(permit.offset, 0x44))                 // loads permit.offset 0x44..0x63\n\n                    calldatacopy(add(ptr, 0x44), permit.offset, 0x20)            // store value     = copy permit.offset 0x00..0x19\n                    mstore(add(ptr, 0x64), sub(deadline, 1))                     // store deadline  = deadline - 1\n                    mstore(add(ptr, 0x84), add(27, shr(255, vs)))                // store v         = most significant bit of vs + 27 (27 or 28)\n                    calldatacopy(add(ptr, 0xa4), add(permit.offset, 0x24), 0x20) // store r         = copy permit.offset 0x24..0x43\n                    mstore(add(ptr, 0xc4), shr(1, shl(1, vs)))                   // store s         = vs without most significant bit\n                }\n                // IERC20Permit.permit(address owner, address spender, uint256 value, uint256 deadline, uint8 v, bytes32 r, bytes32 s)\n                success := call(gas(), token, 0, ptr, 0xe4, 0, 0)\n            }\n            // Compact IDaiLikePermit\n            case 72 {\n                mstore(ptr, daiPermitSelector)  // store selector\n                mstore(add(ptr, 0x04), owner)   // store owner\n                mstore(add(ptr, 0x24), spender) // store spender\n\n                // Compact IDaiLikePermit.permit(uint32 nonce, uint32 expiry, uint256 r, uint256 vs)\n                {  // stack too deep\n                    let expiry := shr(224, calldataload(add(permit.offset, 0x04))) // loads permit.offset 0x04..0x07\n                    let vs := calldataload(add(permit.offset, 0x28))               // loads permit.offset 0x28..0x47\n\n                    mstore(add(ptr, 0x44), shr(224, calldataload(permit.offset))) // store nonce   = copy permit.offset 0x00..0x03\n                    mstore(add(ptr, 0x64), sub(expiry, 1))                        // store expiry  = expiry - 1\n                    mstore(add(ptr, 0x84), true)                                  // store allowed = true\n                    mstore(add(ptr, 0xa4), add(27, shr(255, vs)))                 // store v       = most significant bit of vs + 27 (27 or 28)\n                    calldatacopy(add(ptr, 0xc4), add(permit.offset, 0x08), 0x20)  // store r       = copy permit.offset 0x08..0x27\n                    mstore(add(ptr, 0xe4), shr(1, shl(1, vs)))                    // store s       = vs without most significant bit\n                }\n                // IDaiLikePermit.permit(address holder, address spender, uint256 nonce, uint256 expiry, bool allowed, uint8 v, bytes32 r, bytes32 s)\n                success := call(gas(), token, 0, ptr, 0x104, 0, 0)\n            }\n            // IERC20Permit\n            case 224 {\n                mstore(ptr, permitSelector)\n                calldatacopy(add(ptr, 0x04), permit.offset, permit.length) // copy permit calldata\n                // IERC20Permit.permit(address owner, address spender, uint256 value, uint256 deadline, uint8 v, bytes32 r, bytes32 s)\n                success := call(gas(), token, 0, ptr, 0xe4, 0, 0)\n            }\n            // IDaiLikePermit\n            case 256 {\n                mstore(ptr, daiPermitSelector)\n                calldatacopy(add(ptr, 0x04), permit.offset, permit.length) // copy permit calldata\n                // IDaiLikePermit.permit(address holder, address spender, uint256 nonce, uint256 expiry, bool allowed, uint8 v, bytes32 r, bytes32 s)\n                success := call(gas(), token, 0, ptr, 0x104, 0, 0)\n            }\n            // Compact IPermit2\n            case 96 {\n                // Compact IPermit2.permit(uint160 amount, uint32 expiration, uint32 nonce, uint32 sigDeadline, uint256 r, uint256 vs)\n                mstore(ptr, permit2Selector)  // store selector\n                mstore(add(ptr, 0x04), owner) // store owner\n                mstore(add(ptr, 0x24), token) // store token\n\n                calldatacopy(add(ptr, 0x50), permit.offset, 0x14)             // store amount = copy permit.offset 0x00..0x13\n                // and(0xffffffffffff, ...) - conversion to uint48 \n                mstore(add(ptr, 0x64), and(0xffffffffffff, sub(shr(224, calldataload(add(permit.offset, 0x14))), 1))) // store expiration = ((permit.offset 0x14..0x17 - 1) & 0xffffffffffff)\n                mstore(add(ptr, 0x84), shr(224, calldataload(add(permit.offset, 0x18)))) // store nonce = copy permit.offset 0x18..0x1b\n                mstore(add(ptr, 0xa4), spender)                               // store spender\n                // and(0xffffffffffff, ...) - conversion to uint48\n                mstore(add(ptr, 0xc4), and(0xffffffffffff, sub(shr(224, calldataload(add(permit.offset, 0x1c))), 1))) // store sigDeadline = ((permit.offset 0x1c..0x1f - 1) & 0xffffffffffff)\n                mstore(add(ptr, 0xe4), 0x100)                                 // store offset = 256\n                mstore(add(ptr, 0x104), 0x40)                                 // store length = 64\n                calldatacopy(add(ptr, 0x124), add(permit.offset, 0x20), 0x20) // store r      = copy permit.offset 0x20..0x3f\n                calldatacopy(add(ptr, 0x144), add(permit.offset, 0x40), 0x20) // store vs     = copy permit.offset 0x40..0x5f\n                // IPermit2.permit(address owner, PermitSingle calldata permitSingle, bytes calldata signature)\n                success := call(gas(), _PERMIT2, 0, ptr, 0x164, 0, 0)\n            }\n            // IPermit2\n            case 352 {\n                mstore(ptr, permit2Selector)\n                calldatacopy(add(ptr, 0x04), permit.offset, permit.length) // copy permit calldata\n                // IPermit2.permit(address owner, PermitSingle calldata permitSingle, bytes calldata signature)\n                success := call(gas(), _PERMIT2, 0, ptr, 0x164, 0, 0)\n            }\n            // Unknown\n            default {\n                mstore(ptr, _PERMIT_LENGTH_ERROR)\n                revert(ptr, 4)\n            }\n        }\n    }\n\n    /**\n     * @dev Executes a low level call to a token contract, making it resistant to reversion and erroneous boolean returns.\n     * @param token The IERC20 token contract on which the call will be made.\n     * @param selector The function signature that is to be called on the token contract.\n     * @param to The address to which the token amount will be transferred.\n     * @param amount The token amount to be transferred.\n     * @return success A boolean indicating if the call was successful. Returns 'true' on success and 'false' on failure. \n     * In case of success but no returned data, validates that the contract code exists.\n     * In case of returned data, ensures that it's a boolean `true`.\n     */\n    function _makeCall(\n        IERC20 token,\n        bytes4 selector,\n        address to,\n        uint256 amount\n    ) private returns (bool success) {\n        assembly (\"memory-safe\") { // solhint-disable-line no-inline-assembly\n            let data := mload(0x40)\n\n            mstore(data, selector)\n            mstore(add(data, 0x04), to)\n            mstore(add(data, 0x24), amount)\n            success := call(gas(), token, 0, data, 0x44, 0x0, 0x20)\n            if success {\n                switch returndatasize()\n                case 0 {\n                    success := gt(extcodesize(token), 0)\n                }\n                default {\n                    success := and(gt(returndatasize(), 31), eq(mload(0), 1))\n                }\n            }\n        }\n    }\n\n    /**\n     * @notice Safely deposits a specified amount of Ether into the IWETH contract. Consumes less gas then regular `IWETH.deposit`.\n     * @param weth The IWETH token contract.\n     * @param amount The amount of Ether to deposit into the IWETH contract.\n     */\n    function safeDeposit(IWETH weth, uint256 amount) internal {\n        if (amount > 0) {\n            bytes4 selector = IWETH.deposit.selector;\n            assembly (\"memory-safe\") { // solhint-disable-line no-inline-assembly\n                mstore(0, selector)\n                if iszero(call(gas(), weth, amount, 0, 4, 0, 0)) {\n                    returndatacopy(0, 0, returndatasize())\n                    revert(0, returndatasize())\n                }\n            }\n        }\n    }\n\n    /**\n     * @notice Safely withdraws a specified amount of wrapped Ether from the IWETH contract. Consumes less gas then regular `IWETH.withdraw`.\n     * @dev Uses inline assembly to interact with the IWETH contract.\n     * @param weth The IWETH token contract.\n     * @param amount The amount of wrapped Ether to withdraw from the IWETH contract.\n     */\n    function safeWithdraw(IWETH weth, uint256 amount) internal {\n        bytes4 selector = IWETH.withdraw.selector;\n        assembly (\"memory-safe\") {  // solhint-disable-line no-inline-assembly\n            mstore(0, selector)\n            mstore(4, amount)\n            if iszero(call(gas(), weth, 0, 0, 0x24, 0, 0)) {\n                let ptr := mload(0x40)\n                returndatacopy(ptr, 0, returndatasize())\n                revert(ptr, returndatasize())\n            }\n        }\n    }\n\n    /**\n     * @notice Safely withdraws a specified amount of wrapped Ether from the IWETH contract to a specified recipient.\n     * Consumes less gas then regular `IWETH.withdraw`.\n     * @param weth The IWETH token contract.\n     * @param amount The amount of wrapped Ether to withdraw from the IWETH contract.\n     * @param to The recipient of the withdrawn Ether.\n     */\n    function safeWithdrawTo(IWETH weth, uint256 amount, address to) internal {\n        safeWithdraw(weth, amount);\n        if (to != address(this)) {\n            assembly (\"memory-safe\") {  // solhint-disable-line no-inline-assembly\n                if iszero(call(_RAW_CALL_GAS_LIMIT, to, amount, 0, 0, 0, 0)) {\n                    let ptr := mload(0x40)\n                    returndatacopy(ptr, 0, returndatasize())\n                    revert(ptr, returndatasize())\n                }\n            }\n        }\n    }\n}\n"
    },
    "contracts/libraries/StringUtil.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\n/// @title Library with gas-efficient string operations\nlibrary StringUtil {\n    function toHex(uint256 value) internal pure returns (string memory) {\n        return toHex(abi.encodePacked(value));\n    }\n\n    function toHex(address value) internal pure returns (string memory) {\n        return toHex(abi.encodePacked(value));\n    }\n\n    /// @dev this is the assembly adaptation of highly optimized toHex16 code from Mikhail Vladimirov\n    /// https://stackoverflow.com/a/69266989\n    function toHex(bytes memory data) internal pure returns (string memory result) {\n        assembly (\"memory-safe\") { // solhint-disable-line no-inline-assembly\n            function _toHex16(input) -> output {\n                output := or(\n                    and(input, 0xFFFFFFFFFFFFFFFF000000000000000000000000000000000000000000000000),\n                    shr(64, and(input, 0x0000000000000000FFFFFFFFFFFFFFFF00000000000000000000000000000000))\n                )\n                output := or(\n                    and(output, 0xFFFFFFFF000000000000000000000000FFFFFFFF000000000000000000000000),\n                    shr(32, and(output, 0x00000000FFFFFFFF000000000000000000000000FFFFFFFF0000000000000000))\n                )\n                output := or(\n                    and(output, 0xFFFF000000000000FFFF000000000000FFFF000000000000FFFF000000000000),\n                    shr(16, and(output, 0x0000FFFF000000000000FFFF000000000000FFFF000000000000FFFF00000000))\n                )\n                output := or(\n                    and(output, 0xFF000000FF000000FF000000FF000000FF000000FF000000FF000000FF000000),\n                    shr(8, and(output, 0x00FF000000FF000000FF000000FF000000FF000000FF000000FF000000FF0000))\n                )\n                output := or(\n                    shr(4, and(output, 0xF000F000F000F000F000F000F000F000F000F000F000F000F000F000F000F000)),\n                    shr(8, and(output, 0x0F000F000F000F000F000F000F000F000F000F000F000F000F000F000F000F00))\n                )\n                output := add(\n                    add(0x3030303030303030303030303030303030303030303030303030303030303030, output),\n                    mul(\n                        and(\n                            shr(4, add(output, 0x0606060606060606060606060606060606060606060606060606060606060606)),\n                            0x0F0F0F0F0F0F0F0F0F0F0F0F0F0F0F0F0F0F0F0F0F0F0F0F0F0F0F0F0F0F0F0F\n                        ),\n                        7 // Change 7 to 39 for lower case output\n                    )\n                )\n            }\n\n            result := mload(0x40)\n            let length := mload(data)\n            let resultLength := shl(1, length)\n            let toPtr := add(result, 0x22) // 32 bytes for length + 2 bytes for '0x'\n            mstore(0x40, add(toPtr, resultLength)) // move free memory pointer\n            mstore(add(result, 2), 0x3078) // 0x3078 is right aligned so we write to `result + 2`\n            // to store the last 2 bytes in the beginning of the string\n            mstore(result, add(resultLength, 2)) // extra 2 bytes for '0x'\n\n            for {\n                let fromPtr := add(data, 0x20)\n                let endPtr := add(fromPtr, length)\n            } lt(fromPtr, endPtr) {\n                fromPtr := add(fromPtr, 0x20)\n            } {\n                let rawData := mload(fromPtr)\n                let hexData := _toHex16(rawData)\n                mstore(toPtr, hexData)\n                toPtr := add(toPtr, 0x20)\n                hexData := _toHex16(shl(128, rawData))\n                mstore(toPtr, hexData)\n                toPtr := add(toPtr, 0x20)\n            }\n        }\n    }\n}\n"
    },
    "contracts/libraries/UniERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol\";\nimport \"../interfaces/IERC20MetadataUppercase.sol\";\nimport \"./SafeERC20.sol\";\nimport \"./StringUtil.sol\";\n\n/// @title Library, which allows usage of ETH as ERC20 and ERC20 itself. Uses SafeERC20 library for ERC20 interface.\nlibrary UniERC20 {\n    using SafeERC20 for IERC20;\n\n    error InsufficientBalance();\n    error ApproveCalledOnETH();\n    error NotEnoughValue();\n    error FromIsNotSender();\n    error ToIsNotThis();\n    error ETHTransferFailed();\n\n    uint256 private constant _RAW_CALL_GAS_LIMIT = 5000;\n    IERC20 private constant _ETH_ADDRESS = IERC20(0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE);\n    IERC20 private constant _ZERO_ADDRESS = IERC20(address(0));\n\n    /// @dev Returns true if `token` is ETH.\n    function isETH(IERC20 token) internal pure returns (bool) {\n        return (token == _ZERO_ADDRESS || token == _ETH_ADDRESS);\n    }\n\n    /// @dev Returns `account` ERC20 `token` balance.\n    function uniBalanceOf(IERC20 token, address account) internal view returns (uint256) {\n        if (isETH(token)) {\n            return account.balance;\n        } else {\n            return token.balanceOf(account);\n        }\n    }\n\n    /// @dev `token` transfer `to` `amount`.\n    /// Note that this function does nothing in case of zero amount.\n    function uniTransfer(\n        IERC20 token,\n        address payable to,\n        uint256 amount\n    ) internal {\n        if (amount > 0) {\n            if (isETH(token)) {\n                if (address(this).balance < amount) revert InsufficientBalance();\n                // solhint-disable-next-line avoid-low-level-calls\n                (bool success, ) = to.call{value: amount, gas: _RAW_CALL_GAS_LIMIT}(\"\");\n                if (!success) revert ETHTransferFailed();\n            } else {\n                token.safeTransfer(to, amount);\n            }\n        }\n    }\n\n    /// @dev `token` transfer `from` `to` `amount`.\n    /// Note that this function does nothing in case of zero amount.\n    function uniTransferFrom(\n        IERC20 token,\n        address payable from,\n        address to,\n        uint256 amount\n    ) internal {\n        if (amount > 0) {\n            if (isETH(token)) {\n                if (msg.value < amount) revert NotEnoughValue();\n                if (from != msg.sender) revert FromIsNotSender();\n                if (to != address(this)) revert ToIsNotThis();\n                if (msg.value > amount) {\n                    // Return remainder if exist\n                    unchecked {\n                        // solhint-disable-next-line avoid-low-level-calls\n                        (bool success, ) = from.call{value: msg.value - amount, gas: _RAW_CALL_GAS_LIMIT}(\"\");\n                        if (!success) revert ETHTransferFailed();\n                    }\n                }\n            } else {\n                token.safeTransferFrom(from, to, amount);\n            }\n        }\n    }\n\n    /// @dev Returns `token` symbol from ERC20 metadata.\n    function uniSymbol(IERC20 token) internal view returns (string memory) {\n        return _uniDecode(token, IERC20Metadata.symbol.selector, IERC20MetadataUppercase.SYMBOL.selector);\n    }\n\n    /// @dev Returns `token` name from ERC20 metadata.\n    function uniName(IERC20 token) internal view returns (string memory) {\n        return _uniDecode(token, IERC20Metadata.name.selector, IERC20MetadataUppercase.NAME.selector);\n    }\n\n    /// @dev Reverts if `token` is ETH, otherwise performs ERC20 forceApprove.\n    function uniApprove(\n        IERC20 token,\n        address to,\n        uint256 amount\n    ) internal {\n        if (isETH(token)) revert ApproveCalledOnETH();\n\n        token.forceApprove(to, amount);\n    }\n\n    /// @dev 20K gas is provided to account for possible implementations of name/symbol\n    /// (token implementation might be behind proxy or store the value in storage)\n    function _uniDecode(\n        IERC20 token,\n        bytes4 lowerCaseSelector,\n        bytes4 upperCaseSelector\n    ) private view returns (string memory result) {\n        if (isETH(token)) {\n            return \"ETH\";\n        }\n\n        (bool success, bytes memory data) = address(token).staticcall{gas: 20000}(\n            abi.encodeWithSelector(lowerCaseSelector)\n        );\n        if (!success) {\n            (success, data) = address(token).staticcall{gas: 20000}(abi.encodeWithSelector(upperCaseSelector));\n        }\n\n        if (success && data.length >= 0x40) {\n            (uint256 offset, uint256 len) = abi.decode(data, (uint256, uint256));\n            /*\n                return data is padded up to 32 bytes with ABI encoder also sometimes\n                there is extra 32 bytes of zeros padded in the end:\n                https://github.com/ethereum/solidity/issues/10170\n                because of that we can't check for equality and instead check\n                that overall data length is greater or equal than string length + extra 64 bytes\n            */\n            if (offset == 0x20 && data.length >= 0x40 + len) {\n                assembly (\"memory-safe\") { // solhint-disable-line no-inline-assembly\n                    result := add(data, 0x40)\n                }\n                return result;\n            }\n        }\n        if (success && data.length == 32) {\n            uint256 len = 0;\n            while (len < data.length && data[len] >= 0x20 && data[len] <= 0x7E) {\n                unchecked {\n                    len++;\n                }\n            }\n\n            if (len > 0) {\n                assembly (\"memory-safe\") { // solhint-disable-line no-inline-assembly\n                    mstore(data, len)\n                }\n                return string(data);\n            }\n        }\n\n        return StringUtil.toHex(address(token));\n    }\n}\n"
    },
    "contracts/MerkleTree.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.17;\n\ninterface IHasher {\n    function hash(uint256 xL, uint256 xR) external pure returns (uint256 xO);\n}\n\ncontract MerkleTree {\n    uint256 public constant FIELD_SIZE = type(uint256).max;\n    uint256 public constant ZERO_VALUE = 0;\n    IHasher public immutable hasher;\n\n    uint32 public levels;\n\n    // the following variables are made public for easier testing and debugging and\n    // are not supposed to be accessed in regular code\n\n    // filledSubtrees and roots could be bytes32[size], but using mappings makes it cheaper because\n    // it removes index range check on every interaction\n    mapping(uint256 => bytes32) public filledSubtrees;\n    bytes32 public root;\n    uint32 public nextIndex = 0;\n\n    constructor(uint32 _levels, IHasher _hasher) {\n        require(_levels > 0, \"_levels should be greater than zero\");\n        require(_levels < 32, \"_levels should be less than 32\");\n        levels = _levels;\n        hasher = _hasher;\n\n        for (uint32 i = 0; i < _levels; i++) {\n            filledSubtrees[i] = zeros(i);\n        }\n\n        root = zeros(_levels - 1);\n    }\n\n    /**\n    @dev Hash 2 tree leaves, returns MiMC(_left, _right)\n  */\n    function hashLeftRight(\n        IHasher _hasher,\n        bytes32 _left,\n        bytes32 _right\n    ) public pure returns (bytes32) {\n        return bytes32(_hasher.hash(uint256(_left), uint256(_right)));\n    }\n\n    function _insert(bytes32 _leaf) internal returns (uint32 index) {\n        uint32 _nextIndex = nextIndex;\n        require(\n            _nextIndex != uint32(2) ** levels,\n            \"Merkle tree is full. No more leaves can be added\"\n        );\n        uint32 currentIndex = _nextIndex;\n        bytes32 currentLevelHash = _leaf;\n        bytes32 left;\n        bytes32 right;\n\n        for (uint32 i = 0; i < levels; i++) {\n            if (currentIndex % 2 == 0) {\n                left = currentLevelHash;\n                right = zeros(i);\n                filledSubtrees[i] = currentLevelHash;\n            } else {\n                left = filledSubtrees[i];\n                right = currentLevelHash;\n            }\n            currentLevelHash = hashLeftRight(hasher, left, right);\n            currentIndex /= 2;\n        }\n\n        nextIndex = _nextIndex + 1;\n        return _nextIndex;\n    }\n\n    /// @dev provides Zero (Empty) elements for a MiMC MerkleTree. Up to 32 levels\n    function zeros(uint256 i) public view returns (bytes32) {\n        require(i < uint32(levels), \"index out of bound\");\n        return 0;\n    }\n}\n"
    },
    "contracts/mocks/MockCoin.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.17;\n\nimport {ERC20} from \"solmate/tokens/ERC20.sol\";\n\ncontract MockUSDC is ERC20 {\n    constructor() ERC20(\"Mock USDC\", \"mUSDC\", 6) {}\n}\n\ncontract MockWETH is ERC20 {\n    constructor() ERC20(\"Mock WETH\", \"mWETH\", 18) {}\n}"
    },
    "contracts/mocks/MockHasher.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.17;\n\nimport {IHasher} from \"../MerkleTree.sol\";\n\n\ncontract MockHasher is IHasher {\n    function hash(uint256 xL, uint256 xR) external override pure returns (uint256 xO) {\n        return xL / 17 * 7 + xR / 37 * 17;\n    }\n}"
    },
    "contracts/mocks/MockVerifier.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.17;\n\nimport {\n    IDepositVerifier,\n    IWithdrawVerifier,\n    ISwapVerifier,\n    IFinalizeVerifier\n} from \"../IVerifier.sol\";\n\ncontract DepositVerifier is IDepositVerifier {\n    function verify(\n        uint256[5] calldata _publicInputs,\n        bytes calldata _proof\n    ) override view public returns(bool) {\n        return true;\n    }\n}\n\ncontract WithdrawVerifier is IWithdrawVerifier {\n    function verify(\n        uint256[5] calldata _publicInputs,\n        bytes calldata _proof\n    ) override view public returns(bool) {\n        return true;\n    }\n}\n\ncontract SwapVerifier is ISwapVerifier {\n    function verify(\n        uint256[4] calldata _publicInputs,\n        bytes calldata _proof\n    ) override view public returns(bool) {\n        return true;\n    }\n}\n\ncontract FinalizeVerifier is IFinalizeVerifier {\n    function verify(\n        uint256[3] calldata _publicInputs,\n        bytes calldata _proof\n    ) override view public returns(bool) {\n        return true;\n    }\n}"
    },
    "contracts/Relayer.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.17;\n\nimport {MerkleTree, IHasher} from \"./MerkleTree.sol\";\nimport {ERC20} from \"solmate/tokens/ERC20.sol\";\nimport {Vault, IRelayer} from \"./Vault.sol\";\nimport {IDepositVerifier, IWithdrawVerifier, ISwapVerifier, IFinalizeVerifier} from \"./IVerifier.sol\";\nimport {IGenericRouter, IAggregationExecutor, SwapDescription} from \"./interfaces/I1nchRouter.sol\";\nimport {IERC20} from \"./libraries/UniERC20.sol\";\n\nenum NodeStatus {\n    EMPTY,\n    TRANSACTED,\n    NULLIFIED\n}\n\nenum SwapDirection {\n    A2B,\n    B2A\n}\n\nstruct ModelOutput {\n    SwapDirection direction;\n    uint248 amount;\n}\n\nstruct ModelInput {\n    uint256 chainlinkPrice;\n}\n\nstruct TxResult {\n    SwapDirection direction;\n    uint120 amountA;\n    uint120 amountB;\n}\n\ncontract Relayer is IRelayer, MerkleTree {\n    \n    ERC20 immutable public TOKEN_A;\n    ERC20 immutable public TOKEN_B;\n    IDepositVerifier public depositVerifier;\n    IWithdrawVerifier public withdrawVerifier;\n    ISwapVerifier public swapVerifier;\n    IFinalizeVerifier public finalizeVerifier;\n    IGenericRouter public genericRouter;\n    IAggregationExecutor public genericExecutor;\n    ModelInput public modelInput;\n    mapping(bytes32 => NodeStatus) public nodeStatusPool;\n    mapping(bytes32 => TxResult) public transactionResults;\n\n    event UploadModel(\n        address indexed relayer,\n        address indexed trader,\n        address vault,\n        bytes32 modelCommitment\n    );\n\n    constructor(\n        ERC20 _tokenA,\n        ERC20 _tokenB,\n        IDepositVerifier _depositVerifier,\n        IWithdrawVerifier _withdrawVerifier,\n        ISwapVerifier _swapVerifier,\n        IFinalizeVerifier _finalizeVerifier,\n        IHasher _hasher,\n        IGenericRouter _genericRouter,\n        IAggregationExecutor _genericExecutor\n    ) MerkleTree(8, _hasher) {\n        TOKEN_A = _tokenA;\n        TOKEN_B = _tokenB;\n        depositVerifier = _depositVerifier;\n        withdrawVerifier = _withdrawVerifier;\n        swapVerifier = _swapVerifier;\n        finalizeVerifier = _finalizeVerifier;\n        genericRouter = _genericRouter;\n        genericExecutor = _genericExecutor;\n    }\n\n    function deposit(\n        bytes32 _cNode,\n        uint256 _balanceA,\n        uint256 _balanceB,\n        address _vault,\n        bytes calldata _proof\n    ) public override returns (uint32) {\n        uint256[5] memory _publicInputs;\n        _publicInputs[0] = uint256(_cNode);\n        _publicInputs[1] = uint256(Vault(_vault).cModel());\n        _publicInputs[2] = uint256(_balanceA);\n        _publicInputs[3] = uint256(_balanceB);\n        _publicInputs[4] = uint256(uint160(_vault));\n        require(msg.sender == _vault, \"vault not match\");\n        require(\n            depositVerifier.verify(_publicInputs, _proof),\n            \"deposit: verify failed\"\n        );\n\n        TOKEN_A.transferFrom(_vault, address(this), _balanceA);\n        TOKEN_B.transferFrom(_vault, address(this), _balanceB);\n\n        return MerkleTree._insert(_cNode);\n    }\n\n    function withdraw(\n        bytes32 _nullifier,\n        uint256 _balanceA,\n        uint256 _balanceB,\n        address _vault,\n        bytes calldata _proof\n    ) public override {\n        uint256[5] memory _publicInputs;\n        _publicInputs[0] = uint256(root);\n        _publicInputs[1] = uint256(_nullifier);\n        _publicInputs[2] = uint256(_balanceA);\n        _publicInputs[3] = uint256(_balanceB);\n        _publicInputs[4] = uint256(uint160(_vault));\n        require(msg.sender == _vault, \"vault not match\");\n        require(\n            nodeStatusPool[_nullifier] == NodeStatus.TRANSACTED,\n            \"transact: invalid node state\"\n        );\n        require(\n            withdrawVerifier.verify(_publicInputs, _proof),\n            \"withdraw: verify failed\"\n        );\n\n        TOKEN_A.transferFrom(address(this), _vault, _balanceA);\n        TOKEN_B.transferFrom(address(this), _vault, _balanceB);\n\n        nodeStatusPool[_nullifier] = NodeStatus.NULLIFIED;\n    }\n\n    function transact(\n        bytes32 _nullifier,\n        ModelOutput calldata modelOutput,\n        bytes calldata _proof,\n        bytes calldata _1inchV5Data\n    ) public {\n        uint256[4] memory _publicInputs;\n        _publicInputs[0] = uint256(MerkleTree.root);\n        _publicInputs[1] = uint256(_nullifier);\n        _publicInputs[2] = modelInput.chainlinkPrice;\n        _publicInputs[3] = uint256(bytes32(abi.encodePacked(modelOutput.direction, modelOutput.amount)));\n        require(\n            nodeStatusPool[_nullifier] == NodeStatus.EMPTY,\n            \"transact: invalid node state\"\n        );\n        require(\n            swapVerifier.verify(_publicInputs, _proof),\n            \"transact: verify failed\"\n        );\n        \n        transactionResults[_nullifier] = _transact(modelOutput, _1inchV5Data);\n        nodeStatusPool[_nullifier] = NodeStatus.TRANSACTED;\n    }\n\n    function finalize(\n        bytes32 _nullifier,\n        bytes32 _cNode2,\n        bytes calldata _proof\n    ) public {\n        uint256[3] memory _publicInputs;\n        _publicInputs[0] = uint256(MerkleTree.root);\n        _publicInputs[1] = uint256(_nullifier);\n        _publicInputs[2] = uint256(_cNode2);\n        require(\n            nodeStatusPool[_nullifier] == NodeStatus.TRANSACTED,\n            \"transact: invalid node state\"\n        );\n        require(\n            finalizeVerifier.verify(_publicInputs, _proof),\n            \"finalize: verify failed\"\n        );\n        \n        MerkleTree._insert(_cNode2);\n        delete transactionResults[_nullifier];\n        nodeStatusPool[_nullifier] = NodeStatus.NULLIFIED;\n    }\n\n    function uploadModel(bytes32 _cModel) public returns(Vault) {\n        Vault vault = new Vault(IRelayer(address(this)), msg.sender, _cModel);\n        emit UploadModel(address(this), msg.sender, address(vault), _cModel);\n        return vault;\n    }\n\n    function _transact(\n        ModelOutput calldata _mOutput,\n        bytes calldata _1inchV5Data\n    ) private returns(TxResult memory txResult) {\n        SwapDescription memory _desc;\n        if (_mOutput.direction == SwapDirection.A2B) {\n            _desc.srcToken = IERC20(address(TOKEN_A));\n            _desc.dstToken = IERC20(address(TOKEN_B));\n        } else {\n            _desc.srcToken = IERC20(address(TOKEN_B));\n            _desc.dstToken = IERC20(address(TOKEN_A));            \n        }\n        _desc.srcReceiver = payable(address(this));\n        _desc.dstReceiver = payable(address(this));\n        _desc.amount = _mOutput.amount;\n        _desc.minReturnAmount = 0;\n        _desc.flags = 4;\n\n        (uint256 returnAmount, uint256 spentAmount) = genericRouter.swap(\n            genericExecutor, _desc, abi.encodePacked(), _1inchV5Data\n        );\n        txResult.direction = _mOutput.direction;\n        if (_mOutput.direction == SwapDirection.A2B) {\n            txResult.amountA = uint120(spentAmount);\n            txResult.amountB = uint120(returnAmount);\n        } else {\n            txResult.amountB = uint120(spentAmount);\n            txResult.amountA = uint120(returnAmount); \n        }\n    }\n}\n"
    },
    "contracts/Vault.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.17;\nimport {ERC20} from \"solmate/tokens/ERC20.sol\";\nimport {Owned} from \"solmate/auth/Owned.sol\";\nimport {IGenericRouter, IAggregationExecutor, SwapDescription} from \"./interfaces/I1nchRouter.sol\";\nimport {IERC20} from \"./libraries/UniERC20.sol\";\n\ninterface IRelayer {\n    function deposit(\n        bytes32 _cNode,\n        uint256 _balanceA,\n        uint256 _balanceB,\n        address _vault,\n        bytes calldata _proof\n    ) external returns (uint32);\n\n    function withdraw(\n        bytes32 _nullifier,\n        uint256 _balanceA,\n        uint256 _balanceB,\n        address _vault,\n        bytes calldata _proof\n    ) external;\n\n    function TOKEN_A() external returns (ERC20);\n    function TOKEN_B() external returns (ERC20);\n    function genericRouter() external returns (IGenericRouter);\n    function genericExecutor() external returns (IAggregationExecutor);\n}\n\nenum VaultState {\n    DEPOSIT,\n    WAITING,\n    WITHDRAW\n}\n\ncontract Vault is Owned {\n    \n    IRelayer immutable public relayer;\n    bytes32 public cModel;\n    mapping(address => uint256) public userWeights;\n    uint256 public totalWeights;\n    uint256 public afterBalance;\n    VaultState public state;\n\n    constructor(\n        IRelayer _relayer,\n        address _trader,\n        bytes32 _cModel\n    ) Owned(_trader) {\n        relayer = _relayer;\n        cModel = _cModel;\n        relayer.TOKEN_A().approve(address(relayer), type(uint256).max);\n        relayer.TOKEN_B().approve(address(relayer), type(uint256).max);\n    }\n\n    modifier requireState(VaultState _state) {\n        require(state == _state, \"Invalid Vault state\");\n        _;\n    }\n\n    function userDeposit(uint256 amount) public requireState(VaultState.DEPOSIT) {\n        relayer.TOKEN_A().transferFrom(msg.sender, address(this), amount);\n        userWeights[msg.sender] += amount;\n        totalWeights += amount;\n    }\n\n    function depositToRelayer(\n        bytes32 _cNode,\n        bytes calldata _proof,\n        bytes calldata _1inchV5Data\n    ) public requireState(VaultState.DEPOSIT) onlyOwner {\n        uint256 initBalanceA = relayer.TOKEN_A().balanceOf(address(this));\n        SwapDescription memory desc = SwapDescription(\n            IERC20(address(relayer.TOKEN_A())),\n            IERC20(address(relayer.TOKEN_B())),\n            payable(address(this)),\n            payable(address(this)), \n            initBalanceA / 2,\n            0,\n            4\n        );\n        relayer.genericRouter().swap(\n            relayer.genericExecutor(), desc, abi.encodePacked(), _1inchV5Data\n        );\n        uint256 balanceA = relayer.TOKEN_A().balanceOf(address(this));\n        uint256 balanceB = relayer.TOKEN_B().balanceOf(address(this));\n        relayer.deposit(_cNode, balanceA, balanceB, address(this), _proof);\n        state = VaultState.WAITING;\n    }\n\n    function withdrawFromRelayer(\n        bytes32 _nullifier,\n        uint256 _balanceA,\n        uint256 _balanceB,\n        bytes calldata _proof,\n        bytes calldata _1inchV5Data\n    ) public requireState(VaultState.WAITING) onlyOwner {\n        relayer.withdraw(_nullifier, _balanceA, _balanceB, address(this), _proof);\n        uint256 afterBalanceB = relayer.TOKEN_B().balanceOf(address(this));\n        SwapDescription memory desc = SwapDescription(\n            IERC20(address(relayer.TOKEN_B())),\n            IERC20(address(relayer.TOKEN_A())),\n            payable(address(this)),\n            payable(address(this)), \n            afterBalanceB / 2,\n            0,\n            4\n        );\n        relayer.genericRouter().swap(\n            relayer.genericExecutor(), desc, abi.encodePacked(), _1inchV5Data\n        );\n        afterBalance = relayer.TOKEN_A().balanceOf(address(this));\n        state = VaultState.WITHDRAW;\n    }\n\n    function userWithdraw(address to) public requireState(VaultState.WITHDRAW) {       \n        uint256 amount = afterBalance * userWeights[to] / totalWeights;\n        relayer.TOKEN_A().transferFrom(address(this), to, amount);\n    }\n}"
    },
    "lib/openzeppelin-contracts/contracts/interfaces/IERC1271.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (interfaces/IERC1271.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC1271 standard signature validation method for\n * contracts as defined in https://eips.ethereum.org/EIPS/eip-1271[ERC-1271].\n *\n * _Available since v4.1._\n */\ninterface IERC1271 {\n    /**\n     * @dev Should return whether the signature provided is valid for the provided data\n     * @param hash      Hash of the data to be signed\n     * @param signature Signature byte array associated with _data\n     */\n    function isValidSignature(bytes32 hash, bytes memory signature) external view returns (bytes4 magicValue);\n}\n"
    },
    "lib/openzeppelin-contracts/contracts/token/ERC20/extensions/draft-IERC20Permit.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (token/ERC20/extensions/draft-IERC20Permit.sol)\n\npragma solidity ^0.8.0;\n\n// EIP-2612 is Final as of 2022-11-01. This file is deprecated.\n\nimport \"./IERC20Permit.sol\";\n"
    },
    "lib/openzeppelin-contracts/contracts/token/ERC20/extensions/IERC20Metadata.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (token/ERC20/extensions/IERC20Metadata.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../IERC20.sol\";\n\n/**\n * @dev Interface for the optional metadata functions from the ERC20 standard.\n *\n * _Available since v4.1._\n */\ninterface IERC20Metadata is IERC20 {\n    /**\n     * @dev Returns the name of the token.\n     */\n    function name() external view returns (string memory);\n\n    /**\n     * @dev Returns the symbol of the token.\n     */\n    function symbol() external view returns (string memory);\n\n    /**\n     * @dev Returns the decimals places of the token.\n     */\n    function decimals() external view returns (uint8);\n}\n"
    },
    "lib/openzeppelin-contracts/contracts/token/ERC20/extensions/IERC20Permit.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (token/ERC20/extensions/IERC20Permit.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC20 Permit extension allowing approvals to be made via signatures, as defined in\n * https://eips.ethereum.org/EIPS/eip-2612[EIP-2612].\n *\n * Adds the {permit} method, which can be used to change an account's ERC20 allowance (see {IERC20-allowance}) by\n * presenting a message signed by the account. By not relying on {IERC20-approve}, the token holder account doesn't\n * need to send a transaction, and thus is not required to hold Ether at all.\n */\ninterface IERC20Permit {\n    /**\n     * @dev Sets `value` as the allowance of `spender` over ``owner``'s tokens,\n     * given ``owner``'s signed approval.\n     *\n     * IMPORTANT: The same issues {IERC20-approve} has related to transaction\n     * ordering also apply here.\n     *\n     * Emits an {Approval} event.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     * - `deadline` must be a timestamp in the future.\n     * - `v`, `r` and `s` must be a valid `secp256k1` signature from `owner`\n     * over the EIP712-formatted function arguments.\n     * - the signature must use ``owner``'s current nonce (see {nonces}).\n     *\n     * For more information on the signature format, see the\n     * https://eips.ethereum.org/EIPS/eip-2612#specification[relevant EIP\n     * section].\n     */\n    function permit(\n        address owner,\n        address spender,\n        uint256 value,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) external;\n\n    /**\n     * @dev Returns the current nonce for `owner`. This value must be\n     * included whenever a signature is generated for {permit}.\n     *\n     * Every successful call to {permit} increases ``owner``'s nonce by one. This\n     * prevents a signature from being used multiple times.\n     */\n    function nonces(address owner) external view returns (uint256);\n\n    /**\n     * @dev Returns the domain separator used in the encoding of the signature for {permit}, as defined by {EIP712}.\n     */\n    // solhint-disable-next-line func-name-mixedcase\n    function DOMAIN_SEPARATOR() external view returns (bytes32);\n}\n"
    },
    "lib/openzeppelin-contracts/contracts/token/ERC20/IERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (token/ERC20/IERC20.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC20 standard as defined in the EIP.\n */\ninterface IERC20 {\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n\n    /**\n     * @dev Returns the amount of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the amount of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves `amount` tokens from the caller's account to `to`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address to, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Moves `amount` tokens from `from` to `to` using the\n     * allowance mechanism. `amount` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(address from, address to, uint256 amount) external returns (bool);\n}\n"
    },
    "lib/solmate/src/auth/Owned.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0-only\npragma solidity >=0.8.0;\n\n/// @notice Simple single owner authorization mixin.\n/// @author Solmate (https://github.com/transmissions11/solmate/blob/main/src/auth/Owned.sol)\nabstract contract Owned {\n    /*//////////////////////////////////////////////////////////////\n                                 EVENTS\n    //////////////////////////////////////////////////////////////*/\n\n    event OwnershipTransferred(address indexed user, address indexed newOwner);\n\n    /*//////////////////////////////////////////////////////////////\n                            OWNERSHIP STORAGE\n    //////////////////////////////////////////////////////////////*/\n\n    address public owner;\n\n    modifier onlyOwner() virtual {\n        require(msg.sender == owner, \"UNAUTHORIZED\");\n\n        _;\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                               CONSTRUCTOR\n    //////////////////////////////////////////////////////////////*/\n\n    constructor(address _owner) {\n        owner = _owner;\n\n        emit OwnershipTransferred(address(0), _owner);\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                             OWNERSHIP LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    function transferOwnership(address newOwner) public virtual onlyOwner {\n        owner = newOwner;\n\n        emit OwnershipTransferred(msg.sender, newOwner);\n    }\n}\n"
    },
    "lib/solmate/src/tokens/ERC20.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0-only\npragma solidity >=0.8.0;\n\n/// @notice Modern and gas efficient ERC20 + EIP-2612 implementation.\n/// @author Solmate (https://github.com/transmissions11/solmate/blob/main/src/tokens/ERC20.sol)\n/// @author Modified from Uniswap (https://github.com/Uniswap/uniswap-v2-core/blob/master/contracts/UniswapV2ERC20.sol)\n/// @dev Do not manually set balances without updating totalSupply, as the sum of all user balances must not exceed it.\nabstract contract ERC20 {\n    /*//////////////////////////////////////////////////////////////\n                                 EVENTS\n    //////////////////////////////////////////////////////////////*/\n\n    event Transfer(address indexed from, address indexed to, uint256 amount);\n\n    event Approval(address indexed owner, address indexed spender, uint256 amount);\n\n    /*//////////////////////////////////////////////////////////////\n                            METADATA STORAGE\n    //////////////////////////////////////////////////////////////*/\n\n    string public name;\n\n    string public symbol;\n\n    uint8 public immutable decimals;\n\n    /*//////////////////////////////////////////////////////////////\n                              ERC20 STORAGE\n    //////////////////////////////////////////////////////////////*/\n\n    uint256 public totalSupply;\n\n    mapping(address => uint256) public balanceOf;\n\n    mapping(address => mapping(address => uint256)) public allowance;\n\n    /*//////////////////////////////////////////////////////////////\n                            EIP-2612 STORAGE\n    //////////////////////////////////////////////////////////////*/\n\n    uint256 internal immutable INITIAL_CHAIN_ID;\n\n    bytes32 internal immutable INITIAL_DOMAIN_SEPARATOR;\n\n    mapping(address => uint256) public nonces;\n\n    /*//////////////////////////////////////////////////////////////\n                               CONSTRUCTOR\n    //////////////////////////////////////////////////////////////*/\n\n    constructor(\n        string memory _name,\n        string memory _symbol,\n        uint8 _decimals\n    ) {\n        name = _name;\n        symbol = _symbol;\n        decimals = _decimals;\n\n        INITIAL_CHAIN_ID = block.chainid;\n        INITIAL_DOMAIN_SEPARATOR = computeDomainSeparator();\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                               ERC20 LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    function approve(address spender, uint256 amount) public virtual returns (bool) {\n        allowance[msg.sender][spender] = amount;\n\n        emit Approval(msg.sender, spender, amount);\n\n        return true;\n    }\n\n    function transfer(address to, uint256 amount) public virtual returns (bool) {\n        balanceOf[msg.sender] -= amount;\n\n        // Cannot overflow because the sum of all user\n        // balances can't exceed the max uint256 value.\n        unchecked {\n            balanceOf[to] += amount;\n        }\n\n        emit Transfer(msg.sender, to, amount);\n\n        return true;\n    }\n\n    function transferFrom(\n        address from,\n        address to,\n        uint256 amount\n    ) public virtual returns (bool) {\n        uint256 allowed = allowance[from][msg.sender]; // Saves gas for limited approvals.\n\n        if (allowed != type(uint256).max) allowance[from][msg.sender] = allowed - amount;\n\n        balanceOf[from] -= amount;\n\n        // Cannot overflow because the sum of all user\n        // balances can't exceed the max uint256 value.\n        unchecked {\n            balanceOf[to] += amount;\n        }\n\n        emit Transfer(from, to, amount);\n\n        return true;\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                             EIP-2612 LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    function permit(\n        address owner,\n        address spender,\n        uint256 value,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) public virtual {\n        require(deadline >= block.timestamp, \"PERMIT_DEADLINE_EXPIRED\");\n\n        // Unchecked because the only math done is incrementing\n        // the owner's nonce which cannot realistically overflow.\n        unchecked {\n            address recoveredAddress = ecrecover(\n                keccak256(\n                    abi.encodePacked(\n                        \"\\x19\\x01\",\n                        DOMAIN_SEPARATOR(),\n                        keccak256(\n                            abi.encode(\n                                keccak256(\n                                    \"Permit(address owner,address spender,uint256 value,uint256 nonce,uint256 deadline)\"\n                                ),\n                                owner,\n                                spender,\n                                value,\n                                nonces[owner]++,\n                                deadline\n                            )\n                        )\n                    )\n                ),\n                v,\n                r,\n                s\n            );\n\n            require(recoveredAddress != address(0) && recoveredAddress == owner, \"INVALID_SIGNER\");\n\n            allowance[recoveredAddress][spender] = value;\n        }\n\n        emit Approval(owner, spender, value);\n    }\n\n    function DOMAIN_SEPARATOR() public view virtual returns (bytes32) {\n        return block.chainid == INITIAL_CHAIN_ID ? INITIAL_DOMAIN_SEPARATOR : computeDomainSeparator();\n    }\n\n    function computeDomainSeparator() internal view virtual returns (bytes32) {\n        return\n            keccak256(\n                abi.encode(\n                    keccak256(\"EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)\"),\n                    keccak256(bytes(name)),\n                    keccak256(\"1\"),\n                    block.chainid,\n                    address(this)\n                )\n            );\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                        INTERNAL MINT/BURN LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    function _mint(address to, uint256 amount) internal virtual {\n        totalSupply += amount;\n\n        // Cannot overflow because the sum of all user\n        // balances can't exceed the max uint256 value.\n        unchecked {\n            balanceOf[to] += amount;\n        }\n\n        emit Transfer(address(0), to, amount);\n    }\n\n    function _burn(address from, uint256 amount) internal virtual {\n        balanceOf[from] -= amount;\n\n        // Cannot underflow because a user's balance\n        // will never be larger than the total supply.\n        unchecked {\n            totalSupply -= amount;\n        }\n\n        emit Transfer(from, address(0), amount);\n    }\n}\n"
    }
  },
  "settings": {
    "optimizer": {
      "enabled": false,
      "runs": 200
    },
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata",
          "devdoc",
          "userdoc",
          "storageLayout",
          "evm.gasEstimates"
        ],
        "": [
          "ast"
        ]
      }
    },
    "metadata": {
      "useLiteralContent": true
    },
    "remappings": [
      "@openzeppelin/contracts/=lib/openzeppelin-contracts/contracts/",
      "ds-test/=lib/forge-std/lib/ds-test/src/",
      "erc4626-tests/=lib/openzeppelin-contracts/lib/erc4626-tests/",
      "forge-std/=lib/forge-std/src/",
      "openzeppelin-contracts/=lib/openzeppelin-contracts/",
      "openzeppelin/=lib/openzeppelin-contracts/contracts/",
      "solmate/=lib/solmate/src/",
      "weird-erc20/=lib/weird-erc20/src/"
    ]
  }
}